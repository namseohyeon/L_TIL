## 그리디 알고리즘
+ 현재 상황에서 지금 당장 좋은 것만 고르는 방법(탐욕법)
+ 최소한의 아이디어를 떠올릴 수 있는 능력을 요구
+ 정당성 분석 중요!
    + 단순히 가장 좋아보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토
+ 일반적인 상황에서 그리디 알고리즘은 최적의 해 => 보장x
+ 코테에서는 대부분의 그리디 문제는 탐욕법으로 얻은 해가 최적의 해가되는 상황에서, 이를 추론할 수 있어야 풀리도록 출제
+ ex) 1. 거스름돈
    + 가장 큰 화폐 단위부터 돈을 거슬러줌
    + -> 최적의 해 보장 이유: 큰 단위가 항상 작은 단위의 배수이기 떄문 => 작은 단위릐 동전들을 종합해 다른 해가 나올 수 x
    + 시간복잡도 O(k)
    + 시간복잡도는 거슬러줘야하는 금액과는 무관하며, 동전의 총 종류에만 영향을 받음
    ```
    n=0 
    count=0
    
    array = [500,100,50,10]
    for coin in array:
        count += n // coin
        n%=coin
    ```
### 구현(implementation)
+ 구현이란 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정
+ 알고리즘 대회의 구형 유형문제란?
    + 풀이를 떠올리는 것은 쉽지만, 소스 코드로 옮기기 어려운 문제
    + 예시:
        + 알고리즘은 간단 but 코드가 긴 문제
        + 실수 연산을 다루고, 특정 소수점 자리까지 출력 필요
        + 문자열을 특정한 기준에 따라 끊어 처리해야하는 문제
        + 적절한 라이브러리를 찾아서 사용해야 하는 문제
+ 2차원 공간은 행렬의 의미로 사용됨
    + 열(Column)은 오른쪽으로 갈 수록 y좌표 값이 커짐 
    + 행(Row)는 아래 쪽으로 갈 수록 x좌표 값이 커짐
    + 왼쪽 위가 첫번째 원소로 (0,0)
    ``` 
    for i in range(5):
        for j in ranfe(5):
            print('(',i,',',j,')', end=" ")
        print()
    ```
    + 시뮬레이션 및 완전 탐색문제서는 2차원 공간에서의 방향 벡터가 자주 활용됨
    ```
    # 동, 북, 서, 남
    dx = [0,-1,0,1] #동은 x쪽으로 0, y쪽으로 1
    dy = [1,0,-1,0] #북은 x쪽으로 -1, y쪽으로 0..

    #현재 위치
    x,y = 2,2

    for i in range(4):
        nx = x+dx[i] #방향이동 설정
        ny = y+dy[i] #방향이동 설정
        print(nx,ny)
    ```

    