## 자료형(data type)
* 변수 저장 형식
* 변수관련 연산 시 용이하게 사용
* 클래스
* type을 안적어도 변수할당 가능

### 숫자(integer, float)
ex) a = 1, b = 2.3

### 문자열(string)
ex) a = "abc"


### 리스트(list)
* 대괄호 사용
* 인덱싱은 0부터 사용
* 인덱싱 -1은 맨 뒤 요소, -2는 맨뒤에서 2번째 요소
* 슬라이싱(:)을 사용하여 여러개의 요소를 가져올 수 있다
(앞 인덱스는 이상, 뒤 인덱스는 미만으로 포함되지 않는다. 뒤 인덱스가 없으면 끝까지를 의미)
+ ::-1은 리스트를 거꾸로 출력, ::-2는 뒤에서부터 2칸씩 건너뛰라는 의미

ex) 
1. score = [90, 30, 60] #score[0] = 90, score[1] = 30
2. score = list([90,30,60])  

** type(score) -> list #자료형을 알려준다.   
** type(score[0]) -> int #요소의 자료형을 알려준다.

### 다차원 리스트
ex) [ [1,2], [1,2,3], [1,2,3,4] ]  

** type(score) -> list #자료형을 알려준다. 
** type(score[0]) -> list #요소의 자료형을 알려준다.


### 튜플(tuple)
+ 소괄호 사용
* 인덱싱 사용 가능
* 값 변환, 추가, 삭제 불가능 <u>리스트와의 차이</u>
ex) a = (1,2)  

** type(score) -> tuple #자료형을 알려준다. 

### 문자열(string)
* " "사이에 문자열을 작성
* 인덱싱 가능

ex) word = "hi"  
word[0] #h  
word = "안녕하세요"  
word[:-2] #안녕하 


### 딕셔너리(dict)
+ 중괄호 사용
+ 키: 값 형식  
* 키는 유니크
* 키와 값 문자와 숫자 둘 다 올 수 있음(제한이 있긴 함)  
* dict(a=123, key=456) 이렇게 dict 사용 시 키 값은 문자여야함(함수 호출이기 때문)
* 리스트 사용하지않고, 딕셔너리 사용 이유: 값 찾는 속도가 빠름
* a[123] = 50(수정) a[13]=123(추가) 가능
+ a.get(123) #50
+ a.keys() # 딕셔너리의 모든 키를 반환
ex) a = {123:456, "key":123} #123이 키, 456이 값

### 집합(set)
+ 중괄호 사용
+ 키만 모아 놓은 딕셔너리의 특수 형태
+ a = {1,2,3,1} # 중복 시 중복한 수는 한개만 저장 #{1,2,3}
+ b = set(a) 사용가능
+ Hash

### 불(Bool)
+ True, False
+ and, or, with 연산자 사용 가능 #ex) True and False
+ and는 왼쪽, 오른쪽 모두 True면 True
+ or은 하나만 True면 True
+ True and False or True #앞부터 순서대로
+ 변수에 할당 가능  
ex) c = a>1


